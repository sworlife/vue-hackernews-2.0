'use strict';

const Vue = require('vue');
const fs = require('fs');
const path = require('path');
const LRU = require('lru-cache');
const vueServerRenderer = require('vue-server-renderer');

const { createBundleRenderer } = vueServerRenderer;
const setupDevServer = require('./build/setup-dev-server');

class Engine {
  constructor(app) {
    this.app = app;
    this.config = app.config.vue;
    this.renderer = vueServerRenderer.createRenderer();
    this.renderOptions = this.config.renderOptions;

    if (this.config.cache === true) {
      this.bundleCache = LRU({
        max: 1000,
        maxAge: 1000 * 3600 * 24 * 7,
      });
    }
    this.isProd = app.config.env === 'prod';

    const templatePath = path.resolve(app.baseDir, 'app/web/src/template.html');
    if (this.isProd) {
      // In production: create server renderer using template and built server bundle.
      // The server bundle is generated by vue-ssr-webpack-plugin.
      const template = fs.readFileSync(templatePath, 'utf-8');
      const bundle = require('./dist/vue-ssr-server-bundle.json');
      // The client manifests are optional, but it allows the renderer
      // to automatically infer preload/prefetch links and directly add <script>
      // tags for any async chunks used during render, avoiding waterfall requests.
      const clientManifest = require('./dist/vue-ssr-client-manifest.json');
      this.renderer = this.createRenderer(bundle, {
        template,
        clientManifest,
      });
    } else {
      // In development: setup the dev server with watch and hot-reload,
      // and create a new renderer on bundle / index template update.
      this.readyPromise = setupDevServer(
        app,
        templatePath,
        (bundle, options) => {
          this.renderer = this.createRenderer(bundle, options);
        }
      );
    }
  }


  resolve(file) {
    return path.resolve(__dirname, file);
  }

  createRenderer(bundle, options) {
    // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
    return createBundleRenderer(bundle, Object.assign(options, {
      // for component caching
      cache: this.bundleCache,
      // this is only needed when vue-server-renderer is npm-linked
      basedir: this.resolve('./dist'),
      // recommended for performance
      runInNewContext: false,
    }));
  }

  render(context) {
    return new Promise((resolve, reject) => {
      this.renderer.renderToString(context, (err, html) => {
        if (err) {
          reject(err);
        }
        resolve(html);
      });
    });
  }

  renderBundle(name, context) {
    context.url = context.request.url;
    if (this.isProd) {
      return this.render(context);
    }
    return this.readyPromise.then(() => this.render(context));
  }

  renderString(tpl, locals, options) {
    const vConfig = Object.assign({ template: tpl, data: locals }, options);
    const vm = new Vue(vConfig);
    return new Promise((resolve, reject) => {
      this.renderer.renderToString(vm, (err, html) => {
        if (err) {
          reject(err);
        } else {
          resolve(html);
        }
      });
    });
  }
}

module.exports = Engine;
